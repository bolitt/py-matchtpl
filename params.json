{"name":"Py-matchtpl","tagline":"A python library to match and extract xml/html source with pre-defined template. It provides a convenient and coding-free way for data processing, especially for web page.","body":"======================================\r\npy-matchtpl: xml/html matching library\r\n======================================\r\n\r\nA python library to match and extract xml/html source with pre-defined \r\ntemplate. It provides a convenient and coding-free way for data \r\nprocessing, especially for web page.\r\n\r\nThe features of ``matchtpl`` are summarized as follows:\r\n\r\n* **Easy to use**. The goal is to help developer ease their text-data processing job. \r\n  Only basic knowledge of `jQuery <http://jquery.com>`_ (mostly, *CSSSelector*), one popular javascript\r\n  DOM-manipulation library, is assumed. User only need to provide the XML-template to\r\n  tell how to extract information and what the expected output is, then ``matchtpl`` will \r\n  finish the rest of the work.\r\n\r\n* **User-friendly**. Our toolkit does not require coding in python. If you are to\r\n  do very sophisticated work, py-matchtpl can take over dirty things, such as \r\n  parse html file, extract useful information, organize data into preferrable\r\n  data structures, or streaming into *string* (plaintext) / `json <http://www.json.org/>`_ / `yaml <http://yaml.org/>`_ / python builtin structures (by default).\r\n  \r\n* **Extensibilty**. Currently, it supports three basic types of data structures: \r\n  (1) *string*; (2) *array*; (3) *map*. We can utilize their combination to meet the requirements\r\n  in most cases. What's more, user can provide *UDF* (user-defined function) to customize in his/her \r\n  own way. \r\n\r\nThe fundamental philosophy of ``matchtpl`` is:\r\n\r\n* **Neat**: keep it clean and hide the dirty things.\r\n\r\n* **Simple**: everything looks configurable, declarative and intuitive. (avoid to use complex control flow syntax: ``if``/``for``/``while``.)\r\n\r\n* **Extensible**: leave imagination to user, and any ideas can be integrated in a rapid way.\r\n\r\nInstallation\r\n=====================\r\n\r\nYou can install the latest package from source (or, download and unzip from github)::\r\n\r\n  $ git clone https://github.com/bolitt/py-matchtpl.git\r\n  \r\n  $ python setup.py install\r\n\r\n\r\nor use python easy_install or pip::\r\n\r\n  $ easy_install matchtpl\r\n\r\n  # alternatively install by pip\r\n\r\n  $ pip install matchtpl\r\n\r\n\r\n\r\nBasic Data Structures\r\n=====================\r\n\r\n1. **string**: ``<s></s>``. Typical atom structure, can be post-processed and\r\n   converted into other types, like ``int``, ``float`` and etc.\r\n\r\n2. **array**: ``<array></array>``. An ordered list of data, also known as list.\r\n   It can be retrieved by its index: *array[0]*.\r\n\r\n3. **map**: ``<map></map>``. A key-value based structure, also known as hash or table.\r\n   It can be retrieved by key-like way: *map['name']* or by property-like way: *map.name*.\r\n\r\nWe believe most data can be fit into those data structures or their combinations.\r\n\r\n\r\nKeywords & Elements\r\n-------------------------\r\n\r\nHere are typical keywords:\r\n\r\n* **select**: select target element(s) from document.\r\n    * selector_string (string): CSS3 Selector to choose target.\r\n\r\n* **get**: get internal text | html of target DOM element.\r\n    * type (string): \"text\" | \"html\". \r\n\r\n* **eval**: locally evaluate via python syntax. (Often used to call jquery-like API.)\r\n    * script_text (string): script using python syntax.\r\n\r\n* **default**: default value if none.\r\n    * value (string): default value.\r\n\r\n* **as**: output format in human-readable way.\r\n    * type (string): str | json | yaml. If not provided, will return python builtin data strucutures.\r\n\r\n(Keywords are not limited as above.)\r\n\r\n\r\nAnd extensible elements are:\r\n\r\n* Strucuture element: ``<s></s>``, ``<array></array>``, ``<map></map>`` (see: above).\r\n\r\n* Root element: ``<root></root>``. Act as serilization class, and provide multiple formats to output result.\r\n\r\n* Customized element: ``<action></action>``, where *action* here can be other non-conflictive tag. *action* is a\r\n  customized action provide by user when calling *parser.parse(..., {'action': some_function})*.\r\n\r\n\r\nQuick Start\r\n=====================\r\n\r\nThe example shows how to extract data from html source. \r\nMatchtpl provides an easy way to parse your html file\r\nand format output. It is a real case to extract products\r\ninformation from web page of amazon.com.\r\n\r\n\r\nPython Code\r\n------------------------\r\n\r\nIn python, typical usage often looks like this::\r\n\r\n    #!/usr/bin/env python\r\n\r\n    from matchtpl import MTemplateEnv, MTemplate, MTemplateParser\r\n\t\r\n    if __name__ == '__main__':\r\n        # initialize environment\r\n        env = MTemplateEnv(template = 'tpl_amazon.xml')\r\n        \r\n        # build template\r\n        tpl = MTemplate()\r\n        tpl.build(env)\r\n\r\n        # initialize parser and parse\r\n        parser = MTemplateParser(tpl)\r\n        results = parser.parse('amazon.html')\r\n\r\n\r\nConfigurable Template\r\n------------------------\r\n\r\nThe pre-defined template is written in xml, which acts as a\r\nconfig file to indicates the meta information of the target \r\n(usually another html/xml file or stream). Then,\r\nparser will use the template to guide its processing, and \r\noutput the result::\r\n\r\n    <!-- serilize result as json. (other format is also supported) -->\r\n    <root as=\"json\">\r\n        <!-- the collection of entries are started with 'result_*' in their IDs,\r\n             and each entry is a map -->\r\n        <array select=\"div[id^='result_']\" >\r\n\t    <map>\r\n                <!-- title: get internal text as result -->\r\n                <s key=\"title\" select=\"h3 span.lrg\" get=\"text\" />\r\n                <s key=\"info\" select=\"h3 span.med\" get=\"text\" />\r\n                <!-- image: get src link in jquery-like way -->\r\n                <s key=\"image\" select=\"div.image img.productImage\" eval=\"attr('src')\" />\r\n                <!-- price: pseudo-class of CSSSelector is used -->\r\n                <s key=\"price\" select=\"li.newp span:eq(0)\" get=\"text\" />\r\n                <!-- review: default value is enabled -->\r\n                <s key=\"review\" select=\"span.asinReviewsSummary a\" eval=\"attr('alt')\" default='0' />\r\n            </map>\r\n        </array>\r\n    </root>\r\n\r\n\r\nAfter execution, the output is organized as json::\r\n\r\n    [\r\n        [\r\n            {\r\n                \"image\": \"http://ec4.images-amazon.com/images/I/516Vhic-I9L._AA160_.jpg\", \r\n                \"info\": \"刘亚莉 广东省出版集团，广东经济出版社  (2011-05) - Kindle电子书\", \r\n                \"price\": \"￥1.99\", \r\n                \"review\": \"平均4.4 星\", \r\n                \"title\": \"总经理财务一本通\"\r\n            }, \r\n            // up to 25 results: map\r\n        ]\r\n    ]\r\n\r\n(At present, json, yaml, plaintext or python builtin structures are allowed. More format will be supported later.)\r\n\r\n\r\nFuture Scenarios\r\n=================\r\n\r\nPossible functionalities:\r\n\r\n1. Unix-like pipe: ``|``. Just concatenate output|input step by step.\r\n\r\n2. Interactive. Interaction with pages: like doing automation/login/testing.\r\n\r\n3. Type-casting. convert type into int/float, or direct instantiation of a class.\r\n\r\n4. Regex support ``/^abcd/ABCD/g`` and some basic UDFs, like split/trim/toUpper/toLower.\r\n\r\nProject Links\r\n==============\r\n**Package Release**: https://pypi.python.org/pypi/matchtpl\r\n\r\n**Source Code**: https://github.com/bolitt/py-matchtpl.git \r\n\r\n\r\nContributors\r\n==============\r\n\r\n* v0.1    Tian Lin<bolitt@gmail.com>\r\n  Initialize the project, and alpha release of the library.\r\n\r\n\r\n*Any contributions are welcome!*\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}